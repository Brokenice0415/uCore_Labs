# Notes of uCore

## 操作系统启动

分三个阶段：

- BIOS启动
- Boot启动
- 操作系统kernel启动

### 1. BIOS启动

BIOS存储与ROM中

1. CPU加电后初始化代码段寄存器CS为0xF000，IP寄存器为0xFFF0，执行第一条指令地址为0xFFFF0，指向BIOS程序所在的位置
2. 进入BIOS主要做三件事：
   - 硬件自检，防止有硬件错误
   - 选择启动设备，比如硬盘、U盘等
   - 加载主引导扇区（第一块扇区）的boot程序到内存0x7c00，并把CPU控制权交接

### 2. Boot启动

1. 切换到保护模式，启用分段

   在BIOS阶段系统处于**实模式**，只有20位的地址线有效，只能访问1MB的物理内存，且不受任何保护，存在极大的安全隐患

   在Boot阶段，通过IO设置A20地址线的值为1，进入保护模式，可以访问全部32根地址线，同时启用分段，通过全局描述符表GDT和局部描述符表LDT（uCore中只使用GDT），共可以访问$2^{13}$个段，每个段的最大大小为$2^{32}$字节。

2. 读取操作系统ELF文件到内存

### 3. 操作系统启动

CPU开始执行操作系统可执行文件，初始进行以下工作：

- 初始化中断控制器

- 设置中断描述符表IDT
- 创建内核线程
- ...



## 操作系统中断

分三种中断

- 外部中断（异步）：IO中断、时钟中断、控制台中断等
- 内部中断：除0、越界等
- 陷入中断：试图调用系统调用时触发

中断处理过程：

1. 执行每一条指令后，确认中断处理器是否发送中断请求，若有则在相应时钟脉冲在总线读取中断请求对应的中断向量

2. 根据中断向量找到IDT中存储的系统服务例程对应段选择子，得到段选择子在GDT中找到系统服务例程所在的段基址和属性
3. 比较系统服务例程的特权等级和当前程序特权等级，若不同则进行权限转换，切换当前系统所用栈为内核栈，并保存用户栈信息

4. 保存被打断程序的中断帧，使用内核栈保存被打断程序的eflags、cs、eip、errorCode信息
5. 将系统服务例程的cs、ip等加载到对应寄存器，CPU开始执行系统服务例程

中断恢复略



## 建立段页式管理

 ucore 中段式管理只起到了一个过渡作用，它将逻辑地址不加转换直接映射成线性地址

GDT用来存储任务状态段TSS，保存用户段和内核栈ss:esp信息

> 物理内存大小通过BIOS阶段探测并存储分布信息于内存`0x8000`

1. 第一阶段：boot启动

   由于设定ucore起始虚拟地址与实际起始物理地址相同，都为0x100000

   ```
   虚拟地址 = 线性地址 = 物理地址
   ```

2. 创建初始页目录表，开启分页

   从kern_entry函数开始，到pmm_init函数被执行之前。编译好的ucore自带了一个设置好的页目录表和相应的页表，将0~4M的线性地址一一映射到物理地址。

   

   修改ucore起始虚拟地址为0xC0100000

   然后进行如下操作开启分页模式：

   - 把页目录表起始位置存入CR3寄存器
   - 把CR0的CR0_PG标志位设1

   映射变为：

   ```
   虚拟地址 = 线性地址 = 物理地址									# 0~4MB
   
   虚拟地址 = 线性地址 = 物理地址+0xC0000000			# 0xC0000000 ~ 0xC0000000+4MB
   ```

   

   将运行于0~4MB的内核移动至高虚拟地址0xC0000000

   清空对于0~4MB的页目录表项

   至此映射变为

   ```
   虚拟地址 = 线性地址 = 物理地址+0xC0000000			# 0xC0000000 ~ 0xC0000000+4MB
   ```

   

3. 完善段表和页表

   使用了一个新的段表。这个新段表除了包括内核态的代码段和数据段描述符，还包括用户态的代码段和数据段描述符以及TSS（段）的描述符。

   > 为了防止bootloader代码产生过多耦合，将段表的完善放至这一步，而非在boot启动阶段全部完成。

   将页目录表项补充完成，实现全部虚拟地址的映射

   ```
   虚拟地址 = 线性地址 = 物理地址+0xC0000000
   ```

   

## 缺页错误

可能有三种情况

- 访问不存在的页，页表项全0，该线性地址与物理地址映射未建立或已撤销
- 访问页权限不匹配
- 目标页帧不在内存中，页表项存在但是存在位为0，在磁盘上的swap分区或文件上

当出现上述3种情况之一，就会抛出缺页异常，陷入中断处理

> 使用CR2寄存器存储发生缺页异常的线性地址，以便系统服务例程处理

若地址在虚拟地址范围内，且权限正确，则处理结束后建立新的虚拟地址到物理地址的映射，刷新TLB，调用iret中断回到发生缺页异常的状态，重新执行指令。否则认为这是一次非法访问。



## 页替换

一个基本的原则是：并非所有的物理页都可以交换出去的，只有映射到用户空间且被用户程序直接访问的页面才能被交换，而被内核直接使用的内核空间的页面不能被换出

- 哪些页可以被换出？

  最不常使用的用户使用的页可以被换出

  否则换出内核使用的页会导致内核执行过程变慢，甚至崩溃

- 一个虚拟的页如何与硬盘上的扇区建立对应关系？

  当页被换出，页表中存在位Present置0，对应的PTE此时没有实际作用，可以用来存储与磁盘位置的映射关系

  为了区别0和swap分区映射，swap分区的page 0不使用

- 何时进行换入和换出操作？

  两种方法，一种主动，一种被动

  - 主动：每隔一段时间，系统主动检查页表，将最不常用的页交换到磁盘，保持内存中始终存在空闲页
  - 被动：当应用程序出现缺页错误，需求内存中没有的页时再进行交换，属于按需分配

- 时钟算法优化：

  对于已修改过的脏页，重新写回磁盘的开销比较大，因此在替换中这种页也是不期望优先被替换的

  在原来的时钟位基础上增加脏页标志位，优先选择非脏页，其次优先选择较旧页（时钟位为1）



## 内核进程管理

在ucore中创建了一个内核线程idleproc，是内核的第一个线程，当内核中没有其他线程时才会执行

在ucore中不区分线程与进程

### 进程数据结构

- pid
- 父进程pid
- 进程状态
- 内核栈入口，记录分配给该进程的内核栈位置
  - 对于内核线程，内核栈就是程序运行所在的栈
  - 对于用户进程，内核栈指当发生中断时，下陷到内核态时的运行栈位置，对于每个进程单独分配，不共享，不经内存管理mm维护，进程退出时自动快速回收
- 内存管理信息，由于内核线程信息常驻内存，只在用户进程有效
- 中断帧，指向内核栈某个位置，当发生中断时维护被中断前状态以便恢复
- 上下文信息，用于进程切换
- CR3寄存器值，即页表入口



### pid唯一维护

设置两个变量last_pid和next_safe，分别表示pid取值范围的起终

- 当last_pid加1后位于取值范围内，则此时的last_pid就是分配得到的pid

- 否则若大于设置的最大值MAX_PID，则回滚至last_pid为1，进行下面的重复操作
- 当last_pid超过next_safe，设置next_safe为最大值MAX_PID，行如下操作
  - 遍历进程列表，若last_pid已被使用，那么last_pid加1并判断是否越界，若越界则回滚至1，继续遍历
  - 若未被使用，在此时进程pid夹在last_pid和next_safe之间时，可以将next_safe收缩至此pid
  - 此时未被使用的last_pid就是分配得到的pid

> 原理依然是遍历进程列表，找到未使用的pid，通过next_safe省去了一部分的遍历操作



### 内核线程创建

通过kernel_thread函数设置中断帧，其中中断帧的eip指向一个系统服务例程处理函数

```
pushl %edx # push arg
call *%ebx # call fn
pushl %eax # save the return value of fn(arg)
call do_exit # call do_exit to terminate current thread
```

然后kerbel_thread调用do_fork创建进程

1. 分配并初始化进程控制块（进程数据结构）
2. 分配并初始化内核栈
3. 根据参数选择复制或共享内存mm
4. 从kernel_thread中复制中断帧信息
5. 将进程放入pid映射哈希表、进程链表
6. 设置进程为就绪态
7. 返回pid



## 用户进程创建

>  在没有文件系统时，用户进程的代码入口和代码大小会在boot中和操作系统内核一起被加载
>
>  同时，用户进程由第一个内核线程initproc覆盖而来
>
>  
>
>  **执行过程**
>
>  proc_init【创建idleproc】
>
>  -> init_main【通过kernel_thread调用，创建initproc】
>
>  -> init_main【调用kernel_thread，创建用户进程创建进程】 
>
>  -> usr_main【执行kernel_execve】
>
>  -> kernel_execve【调用系统服务例程】
>
>  -> ... 
>
>  -> do_execve【被系统调用执行，创建用户进程】

通过内核函数kernel_execve读取用户进程代码入口和代码大小，通过硬件指令执行

通过do_execve创建用户进程

- 为加载新的执行码做好对于用户态内存空间的清空准备
  - <u>若mm不为空，表示此时为用户进程，设置页表为内核空间页表，保证后面的操作都在内核虚拟地址空间下运行，以保后面操作的正常进行</u>
  - 若mm引用计数减1后为0，根据mm释放用户进程及其页表所占内存，mm指针设为null
- 调用load_icode读取用户程序ELF、申请用户空间、加载用户程序执行码
  - mm_create：申请用户内存管理
  - setup_pgdir：申请用户页目录所在页，并让mm指向
  - 加载ELF，并根据ELF说明的各个段信息分配虚拟内存地址vma
  - 根据vma申请相应物理内存，建立映射，将各个段内容拷入vma
  - mm_mmap：建立用户栈vma，在用户虚空间顶1MB，分配一定物理内存并建立映射
  - 赋值页目录地址mm->pgdir至cr3寄存器
  - 清空并重设置进程中断帧，从当前的initproc能通过iret回到用户进程执行现场
- iret进入用户进程执行



### 进程回收

当mm不为空也就是用户进程时，回收用户vmm

1. 执行lcr3指令，切换到内核页表状态
2. 若mm引用计数减一后变为0，则回收对应内存
   1. 通过exit_mmap回收current->mm->vma链表中每个vma所分配的内存，清空对应页表项
   2. 释放页表并清空页目录
   3. 通过put_pgdir回收页目录表所在页
   4. 通过mm_destroy释放vma链表所占内存，然后释放mm所占内存
3. 设置current->mm为null

此时内存释放完毕

1. 设置进程状态为ZOMBIE
2. 通过waktup_proc(current->parent)向父进程发信号唤醒，通知回收子进程
3. 子进程的子进程的父进程设置为initproc

执行schedual函数进行调度

父进程将子进程从进程链表和pid链表中删除，释放子进程的栈空间和进程结构体



## 进程切换

通过进程中need_sched维护当前进程是否需要被调度走，当为1时表示需要（如时间片使用完）

1. 设置当前进程的need_sched为0
2. 在进程队列中寻找下一个就绪状态的进程
3. 调用proc_run，保存当前现场，恢复下一进程现场并执行
   - 当前运行进程指针current指向下一进程
   - 设置任务状态段ts
   - 设置CR3寄存器
   - 调用switch_to函数恢复通用寄存器状态



## 管程

是一种对于条件变量使用的封装数据结构，能够统一管理若干临界区

由信号量实现的条件变量

- 二值信号量sem
- 等待队列长度count
- 指向控制该条件变量的管程的指针owner

管程monitor

- 互斥锁mutex
  - 控制进入管程整体的临界区
- 条件变量组cvs
  - 每一个条件变量管理着自己的临界区
- 信号量next
  - 控制进入管程的入口队列
- 剩余等待数next_count
  - 入口队列长度



管程控制临界区方法

```c
cv.count++;
if(monitor.next_count > 0)
   sem_signal(monitor.next);
else
   sem_signal(monitor.mutex);
sem_wait(cv.sem);
cv.count -- ;
```

每次对monitor的next进行P操作，来控制进程进入管程，管程入口队列长度减1，然后将其睡眠在对应的控制条件变量cv上，cv上的等待队列长度加1

直到该进程被此cv唤醒，cv的等待队列长度减1，此时进程就在管程的控制下进入运行running状态

